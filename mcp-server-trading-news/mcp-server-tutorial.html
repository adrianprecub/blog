<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Your Own MCP Server: A Complete Guide</title>
</head>
<body>

<h1>Building Your Own MCP Server: A Complete Guide</h1>

<p>The Model Context Protocol (MCP) provides a standard way for AI assistants to interact with external tools and data sources. This tutorial walks through creating a functional MCP server from scratch, using a real-world example that fetches trading news from financial APIs.</p>

<h2>What You Will Build</h2>

<p>By the end of this guide, you will have a working MCP server that exposes tools AI assistants can use to fetch real-time trading news. The server connects to the Alpha Vantage API and provides structured responses that AI models can process and present to users.</p>

<h2>Prerequisites</h2>

<p>Before starting, ensure you have the following installed on your system:</p>

<ul>
    <li>Java Development Kit (JDK) 21 or higher</li>
    <li>Maven 3.8 or higher</li>
    <li>A text editor or IDE (IntelliJ IDEA, VS Code, or Eclipse)</li>
    <li>An Alpha Vantage API key (free tier available at alphavantage.co)</li>
</ul>

<h2>Step 1: Project Setup</h2>

<p>Create a new directory for your project and navigate to it:</p>

<pre><code>mkdir mcp-server-trading-news
cd mcp-server-trading-news</code></pre>

<p>Create the Maven project structure:</p>

<pre><code>mkdir -p src/main/java/com/trading/news
mkdir -p src/main/java/com/trading/news/model
mkdir -p src/main/resources
mkdir -p src/test/java</code></pre>

<h2>Step 2: Configure the Build File</h2>

<p>Create a <code>pom.xml</code> file in the project root with the following configuration:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.trading.news&lt;/groupId&gt;
    &lt;artifactId&gt;mcp-server-trading-news&lt;/artifactId&gt;
    &lt;name&gt;Trading News MCP Server&lt;/name&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;compiler-plugin.version&gt;3.14.0&lt;/compiler-plugin.version&gt;
        &lt;java.version&gt;21&lt;/java.version&gt;
        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;quarkus.platform.version&gt;3.26.3&lt;/quarkus.platform.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.quarkus.platform&lt;/groupId&gt;
                &lt;artifactId&gt;quarkus-bom&lt;/artifactId&gt;
                &lt;version&gt;${quarkus.platform.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.quarkiverse.mcp&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-mcp-server-sse&lt;/artifactId&gt;
            &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-rest-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-rest-client-jackson&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.quarkus.platform&lt;/groupId&gt;
                &lt;artifactId&gt;quarkus-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;${quarkus.platform.version}&lt;/version&gt;
                &lt;extensions&gt;true&lt;/extensions&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build&lt;/goal&gt;
                            &lt;goal&gt;generate-code&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre>

<p>This configuration sets up Quarkus with the MCP server extension, which handles the protocol implementation details for you.</p>

<h2>Step 3: Create the Data Models</h2>

<p>MCP servers work with structured data. Create model classes to represent the news data.</p>

<p>First, create <code>src/main/java/com/trading/news/model/NewsArticle.java</code>:</p>

<pre><code>package com.trading.news.model;

import com.fasterxml.jackson.annotation.JsonProperty;

public class NewsArticle {
    private String title;
    private String url;
    private String summary;

    @JsonProperty("time_published")
    private String timePublished;

    @JsonProperty("overall_sentiment_label")
    private String sentimentLabel;

    @JsonProperty("overall_sentiment_score")
    private double sentimentScore;

    // Getters and setters
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }

    public String getSummary() { return summary; }
    public void setSummary(String summary) { this.summary = summary; }

    public String getTimePublished() { return timePublished; }
    public void setTimePublished(String timePublished) {
        this.timePublished = timePublished;
    }

    public String getSentimentLabel() { return sentimentLabel; }
    public void setSentimentLabel(String sentimentLabel) {
        this.sentimentLabel = sentimentLabel;
    }

    public double getSentimentScore() { return sentimentScore; }
    public void setSentimentScore(double sentimentScore) {
        this.sentimentScore = sentimentScore;
    }
}</code></pre>

<p>Next, create <code>src/main/java/com/trading/news/model/NewsResponse.java</code>:</p>

<pre><code>package com.trading.news.model;

import java.util.List;

public class NewsResponse {
    private List&lt;NewsArticle&gt; feed;

    public List&lt;NewsArticle&gt; getFeed() { return feed; }
    public void setFeed(List&lt;NewsArticle&gt; feed) { this.feed = feed; }
}</code></pre>

<h2>Step 4: Create the REST Client</h2>

<p>The REST client interfaces with the external API. Create <code>src/main/java/com/trading/news/AlphaVantageNewsClient.java</code>:</p>

<pre><code>package com.trading.news;

import com.trading.news.model.NewsResponse;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.QueryParam;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

@RegisterRestClient(configKey = "alphavantagenews")
@Path("/query")
public interface AlphaVantageNewsClient {

    @GET
    NewsResponse getNewsByCategory(
        @QueryParam("function") String function,
        @QueryParam("topics") String topics,
        @QueryParam("apikey") String apiKey
    );

    @GET
    NewsResponse getNewsByTickers(
        @QueryParam("function") String function,
        @QueryParam("tickers") String tickers,
        @QueryParam("apikey") String apiKey
    );
}</code></pre>

<h2>Step 5: Implement MCP Tools</h2>

<p>MCP tools are the functions that AI assistants can call. Create <code>src/main/java/com/trading/news/AlphaVantageTools.java</code>:</p>

<pre><code>package com.trading.news;

import com.trading.news.model.NewsResponse;
import io.quarkiverse.mcp.server.Tool;
import io.quarkiverse.mcp.server.ToolArg;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.eclipse.microprofile.rest.client.inject.RestClient;

public class AlphaVantageTools {

    private final AlphaVantageNewsClient newsClient;
    private final String apiKey;

    public AlphaVantageTools(
            @RestClient AlphaVantageNewsClient newsClient,
            @ConfigProperty(name = "alphaVantage.api.key") String apiKey) {
        this.newsClient = newsClient;
        this.apiKey = apiKey;
    }

    @Tool(description = "Get general trading news.")
    NewsResponse get_trading_news() {
        return newsClient.getNewsByCategory(
            "NEWS_SENTIMENT",
            "general",
            apiKey
        );
    }

    @Tool(description = "Get trading news by comma-separated tickers.")
    NewsResponse get_trading_news_by_tickers(
            @ToolArg(
                description = "Tickers for which to get the trading news.",
                required = true
            ) String tickers) {
        return newsClient.getNewsByTickers(
            "NEWS_SENTIMENT",
            tickers,
            apiKey
        );
    }
}</code></pre>

<p>The <code>@Tool</code> annotation marks methods as MCP tools. The <code>@ToolArg</code> annotation documents parameters that AI assistants will provide.</p>

<h2>Step 6: Configure the Application</h2>

<p>Create <code>src/main/resources/application.properties</code>:</p>

<pre><code># Run the MCP server on port 8082
quarkus.http.port=8082

# Configure MCP server
quarkus.mcp.server.server-info.name=Trading News Service
quarkus.mcp.server.traffic-logging.enabled=true
quarkus.mcp.server.traffic-logging.text-limit=100

# Configure the REST client
quarkus.rest-client."alphavantagenews".uri=https://www.alphavantage.co/
alphaVantage.api.key=${ALPHAVANTAGE_API_KEY:demo}

# Package as an uber-jar for easy distribution
quarkus.package.jar.type=uber-jar</code></pre>

<p>The configuration uses environment variables for the API key, falling back to "demo" if not set.</p>

<h2>Step 7: Build and Test the Server</h2>

<p>First, set your Alpha Vantage API key as an environment variable:</p>

<pre><code>export ALPHAVANTAGE_API_KEY=your_actual_api_key_here</code></pre>

<p>Build the project:</p>

<pre><code>./mvnw clean compile</code></pre>

<p>Run the server in development mode with hot reload:</p>

<pre><code>./mvnw quarkus:dev</code></pre>

<p>The server will start on port 8082. You should see output indicating the MCP server is running.</p>

<h2>Step 8: Test the MCP Server</h2>

<p>To verify your server works correctly, test it using Postman. The MCP protocol uses Server-Sent Events (SSE) for communication.</p>

<p><strong>Setting up Postman for SSE testing:</strong></p>

<ol>
    <li>Open Postman and create a new request</li>
    <li>Set the request type to <code>GET</code></li>
    <li>Enter the URL: <code>http://localhost:8082/mcp/sse</code></li>
    <li>In the Headers tab, add: <code>Accept: text/event-stream</code></li>
    <li>Click Send and switch to the "Preview" or "Raw" response view</li>
</ol>

<p>The SSE connection will stream events containing your server information and available tools. You should see output similar to:</p>

<pre><code>data: {"jsonrpc":"2.0","method":"tools/list","params":{"tools":[
  {"name":"get_trading_news","description":"Get general trading news."},
  {"name":"get_trading_news_by_tickers","description":"Get trading news by comma-separated tickers."}
]}}</code></pre>

<p><strong>Testing tool invocation:</strong></p>

<p>Since MCP uses SSE for bidirectional communication, testing individual tool calls requires sending formatted JSON-RPC messages. For comprehensive testing, consider using the MCP Inspector tool or creating a simple test client that properly handles the SSE protocol.</p>

<h2>Step 9: Connect to an AI Assistant</h2>

<p>To use your MCP server with Claude or another AI assistant that supports MCP, you need to configure the assistant to connect to your server. The exact configuration depends on your client, but typically involves:</p>

<ol>
    <li>Adding your server URL (http://localhost:8082) to the MCP server list</li>
    <li>Specifying the server type as SSE (Server-Sent Events)</li>
    <li>Restarting the AI assistant client</li>
</ol>

<p>Once connected, the AI assistant will discover your tools automatically and can call them when users ask for trading news.</p>

<h2>Step 10: Package for Production</h2>

<p>Build a standalone JAR file for deployment:</p>

<pre><code>./mvnw clean package</code></pre>

<p>This creates an uber-jar in the <code>target</code> directory containing all dependencies. Run it with:</p>

<pre><code>java -jar target/mcp-server-trading-news-1.0.0-SNAPSHOT-runner.jar</code></pre>

<p>For production deployment, consider containerizing the application using Docker:</p>

<pre><code># Create a Dockerfile
FROM eclipse-temurin:21-jre
COPY target/*-runner.jar app.jar
EXPOSE 8082
ENTRYPOINT ["java", "-jar", "/app.jar"]</code></pre>

<h2>Understanding the Architecture</h2>

<p>The MCP server architecture consists of several layers working together:</p>

<p><strong>Protocol Layer:</strong> The Quarkus MCP extension handles the SSE protocol, message formatting, and communication with AI clients. You don't need to implement protocol details.</p>

<p><strong>Tool Layer:</strong> Your tool methods define what capabilities the AI assistant gains. Each tool should have a clear purpose and return structured data the AI can interpret.</p>

<p><strong>Integration Layer:</strong> REST clients and other integrations connect your tools to external services. This separation keeps your tools focused on their interface to the AI.</p>

<p><strong>Configuration Layer:</strong> Application properties control server behavior, API endpoints, and security settings. Use environment variables for sensitive configuration.</p>

<h2>Best Practices for MCP Server Development</h2>

<p><strong>Tool Design:</strong> Keep tools focused on single responsibilities. A tool that fetches news should only fetch news, not also analyze or format it. Let the AI assistant handle presentation.</p>

<p><strong>Error Handling:</strong> Return meaningful error messages that help the AI understand what went wrong. Avoid exposing internal implementation details or stack traces.</p>

<p><strong>Documentation:</strong> Use descriptive tool and argument annotations. The AI assistant relies on these descriptions to understand when and how to use your tools.</p>

<p><strong>Performance:</strong> Consider caching responses for expensive operations. The Alpha Vantage API has rate limits, so cache recent responses to avoid hitting limits during development.</p>

<p><strong>Security:</strong> Never expose sensitive credentials through tool responses. Use proper authentication and validate all inputs, even though they come from the AI assistant.</p>

<h2>Extending Your Server</h2>

<p>Once your basic server works, consider adding these features:</p>

<p><strong>Additional Tools:</strong> Add tools for technical analysis, historical data, or market statistics. Each new capability makes your server more useful.</p>

<p><strong>Response Caching:</strong> Implement a simple cache to store recent API responses. This improves performance and helps stay within API rate limits.</p>

<p><strong>Data Enrichment:</strong> Process raw API responses to add calculated fields, summaries, or derived insights before returning them to the AI.</p>

<p><strong>Monitoring:</strong> Add health checks and metrics to monitor your server's performance and usage patterns in production.</p>

<h2>Troubleshooting Common Issues</h2>

<p><strong>Server won't start:</strong> Check that port 8082 is available and no other process is using it. Verify your Java version meets the minimum requirement.</p>

<p><strong>API calls fail:</strong> Confirm your API key is valid and properly set in the environment. Check the Alpha Vantage API status and your rate limits.</p>

<p><strong>Tools don't appear in the AI assistant:</strong> Ensure your tool methods have the correct annotations and return types. Check the server logs for registration errors.</p>

<p><strong>Connection drops:</strong> SSE connections can timeout. Configure your server and any proxies to maintain long-lived connections.</p>

<h2>Conclusion</h2>

<p>You now have a working MCP server that provides trading news to AI assistants. This foundation can be extended with additional tools, data sources, and capabilities based on your specific needs.</p>

<p>The MCP protocol abstracts the complexity of AI-tool communication, letting you focus on building useful capabilities. As the ecosystem grows, your server can integrate with more AI assistants and automation platforms that support the protocol.</p>

<p>Remember to keep your tools simple, well-documented, and focused on providing value to the AI assistant's users. Good MCP servers enhance AI capabilities without adding complexity for end users.</p>

</body>
</html>